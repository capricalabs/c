/* ---------------------------------------------------------------------------- * *   Rudimentary clone of IcyTower * * *   Note: only fragments of the code are included below * * *//* --- file: jumpjump.h ----------------------------------------------------- */#include <config.h>#include <errno.h>#include <math.h>#include <stdlib.h>#include <string.h>#include <stdarg.h>#include <time.h>#include <SDL/SDL.h>#include <SDL/SDL_image.h>#include <SDL/SDL_ttf.h>#include <common.h>#define BASE_WIDTH 480#define BASE_HEIGHT 640#define MAP_WIDTH BASE_WIDTH#define MAP_HEIGHT BASE_HEIGHT/* screen */typedef struct screen_t screen_t;struct screen_t {    SDL_Surface *surface;};screen_t *screen_new();void screen_free(screen_t *s);void screen_resize(screen_t *s, Uint16 w, Uint16 h);/* level */typedef struct level_t level_t;struct level_t {    Uint32 start_floor;    double minf;    double maxf;    double speed;    char path[32];    SDL_Surface *surface;};level_t *levels_new(map_t *m, const char *path, Uint32 *count);void levels_free(level_t *l, Uint32 count);/* floor */typedef struct floor_t floor_t;struct floor_t {    floor_t *next;    Sint16 x, y;    Uint16 w, h;    Uint16 index;    Uint8 level;    Uint8 busy;    SDL_Surface *surface;};floor_t *floor_new(map_t *m, Uint16 index);void floor_free(floor_t *f);/* map */typedef struct map_t map_t;struct map_t {    game_t *game;    Sint16 real_x0, real_x1;    Uint16 real_w;    Sint16 x0, x1, y0, y1;    Uint16 w, h;    double speed;    SDL_Surface *surface_bg;    SDL_Surface *surface_wall;    floor_t *floor_head;    floor_t *floor_tail;    Sint8 draw_wall;    Uint8 floor_cheat;    Sint8 level;    level_t *levels;    Uint32 levels_count;};map_t *map_new(game_t *g, Sint16 x, Sint16 y, Uint16 w, Uint16 h);void map_free(map_t *m);void map_scroll(map_t *m);void map_draw(map_t *m, SDL_Surface *s);void map_tick(map_t *m, Uint32 dt);/* hero */typedef struct hero_t hero_t;struct hero_t {    /* note: only here x/y point to bottom left corner */    Sint16 x, y;    /* velocity */    double vx, vy;    Uint8 alive;    /* FIXME improve this */    double power;    /* boolean values */    Uint8 left_req;    Uint8 right_req;    Uint8 jump_req;    game_t *game;    map_t *map;    bar_t *bar;    floor_t *floor;    SDL_Surface *glyph;    SDL_Surface *glyphs[2][10];};hero_t *hero_new(game_t *g, map_t *m, bar_t *b);void hero_free(hero_t *h);void hero_draw(hero_t *h, SDL_Surface *s);void hero_tick(hero_t *h, Uint32 dt);/* bar */typedef struct bar_t bar_t;struct bar_t {    TTF_Font *font;    SDL_Surface *score_surface;    SDL_Surface *level_surface;        Sint16 x0, x1;    Sint16 score;    Sint16 score_x;    Sint8 level;    Sint16 level_x;};bar_t *bar_new(game_t *g, Sint16 x0, Uint16 w);void bar_free(bar_t *b);void bar_update(bar_t *b);void bar_draw(bar_t *b, SDL_Surface *s);/* game */typedef enum game_state {    GAME_READY,    GAME_PLAY,    GAME_PAUSED,    GAME_OVER,    GAME_QUIT} game_state;typedef struct game_t game_t;struct game_t {    game_state state;    map_t **map;    hero_t **hero;    bar_t **bar;    Uint8 nplayers;    screen_t *screen;};game_t *game_new(screen_t *s, Uint8 nplayers);void game_free(game_t *g);void game_loop(game_t *g);/* effects */void surface_blend_1(SDL_Surface *src, SDL_Surface *dest);void surface_blend_2(SDL_Surface *src, SDL_Surface *dest);void intro_draw(screen_t *screen);/* menu */typedef struct menu_t menu_t;struct menu_t {    Sint8 cur_pos;    Sint16 cur_x, cur_y;    screen_t *screen;    TTF_Font *title_font, *item_font;    SDL_Surface *title_pict, *item_bullet;};menu_t *menu_new(screen_t *s);void menu_free(menu_t *m);void menu_run(menu_t *m);/* message */typedef struct message_t message_t;struct message_t {    SDL_Surface *save_surface, *message_surface, *surface;    SDL_Rect rect;};message_t *message_new(SDL_Surface *surface, const char *text);void message_draw(message_t *m);void message_free(message_t *m);/* --- file: screen.c ------------------------------------------------------- */#include "jumpjump.h"#define SCREEN_BPP 16#define SCREEN_FLAGS 0 // (SDL_HWSURFACE | SDL_DOUBLEBUF)screen_t *screen_new(){    screen_t *s;        s = xmalloc(sizeof(screen_t));    if (SDL_Init(SDL_INIT_VIDEO) == -1)        fatal("couldn't initialize sdl");    if (TTF_Init() == -1)        fatal("couldn't initialize sdl_ttf");    s->surface = SDL_SetVideoMode(BASE_WIDTH, BASE_HEIGHT,            SCREEN_BPP, SCREEN_FLAGS);    SDL_WM_SetCaption(PACKAGE_STRING, NULL);    debug("screen initialized");    return s;}voidscreen_resize(screen_t *s, Uint16 w, Uint16 h){    if (s->surface->w == w && s->surface->h == h)        return;    SDL_Surface *save;    save = surface_new(s->surface->w, s->surface->h);    surface_blit(0, 0, s->surface, save);    s->surface = SDL_SetVideoMode(w, h, SCREEN_BPP, SCREEN_FLAGS);    surface_blit(0, 0, save, s->surface);    SDL_Flip(s->surface);    SDL_FreeSurface(save);    debug("screen resized: %ux%u", w, h);}voidscreen_free(screen_t *s){    TTF_Quit();    SDL_Quit();    free(s);    debug("screen freed");}/* --- file: hero.c --------------------------------------------------------- */#include "jumpjump.h"#define HERO_STAND_0 0#define HERO_STAND_1 1#define HERO_RUN_0 2#define HERO_RUN_1 3#define HERO_RUN_2 4#define HERO_RUN_3 5#define HERO_RUN_4 6#define HERO_RUN_5 7#define HERO_RISE_0 8#define HERO_FALL_0 9#define PHYS_MIN_YSPEED 3#define PHYS_MAX_YSPEED 3#define PHYS_AIR_ACCEL 0.0005#define PHYS_GND_ACCEL 0.001#define PHYS_GRV_ACCEL 0.002#define PHYS_AIR_RESISTANCE 0.0005#define PHYS_GND_RESISTANCE 0.003#define PHYS_RESTITUTION 0.3#define PHYS_LAND_POWER 1000#define PHYS_JUMP_POWER_COEFF 0.0002#define PHYS_JUMP_SPEED_COEFF 0.45#define PHYS_JUMP_BASE 0.9static void hero_anim(hero_t *h, Uint32 dt);static floor_t *hero_on_floor(hero_t *h);static void hero_fix(hero_t *h, Uint32 dt);static void hero_physics(hero_t *h, Uint32 dt);static voidhero_anim(hero_t *h, Uint32 dt){    static Sint32 wait = 0;    static int last_fr = 0;    static int dir = 1;    int fr = last_fr;    wait -= dt;    dir = h->vx == 0 ? dir : (h->vx < 0 ? 0 : 1);    if (h->vy != 0 && h->vy < 0.5) {        fr = HERO_RISE_0;    } else if (h->vy > 0.5) {        fr = HERO_FALL_0;    } else if (h->vx == 0) {        /* standing */        if (last_fr == HERO_STAND_0 && wait < 0) {            fr = HERO_STAND_1;            wait = 300;        } else if ((last_fr == HERO_STAND_1 && wait < 0)                   || last_fr < HERO_STAND_0                   || last_fr > HERO_STAND_1) {            fr = HERO_STAND_0;            wait = 2000;        }    } else {        /* running */        if (last_fr < HERO_RUN_0 || last_fr > HERO_RUN_5) {            fr = HERO_RUN_0;            wait = 100;        } else if (wait < 0) {            fr = last_fr + 1;            if (fr > HERO_RUN_5) {                fr = HERO_RUN_0;            }            wait = 100;        }    }    last_fr = fr;    h->glyph = h->glyphs[dir][fr];}static floor_t *hero_on_floor(hero_t *h){    map_t *m;    floor_t *f;    m = h->map;    FOREACH(f, m->floor_head) {        if (h->y == f->y - 1)            break;    }    if (f && (h->x + h->glyph->clip_rect.w >= f->x)          && (h->x <= f->x + f->w))        return f;    return 0;}static voidhero_fix(hero_t *h, Uint32 dt){    map_t *m;    floor_t *f;    m = h->map;    while (h->y < 100) {        map_scroll(m);        h->y++;    }    if (h->x < m->x0) {        h->x = m->x0;        h->vx = -h->vx * PHYS_RESTITUTION;    }    if (h->x + h->glyph->clip_rect.w -1 >= m->x1) {        h->x = m->x1 - h->glyph->clip_rect.w;        h->vx = -h->vx * PHYS_RESTITUTION;    }    if ((h->y - h->glyph->h) > m->y1)        h->alive = 0;    if (h->floor)        h->y = h->floor->y - 1;    if (h->vy < 0) {        if (h->floor)            h->floor->busy = 0;        h->floor = 0;    } else {         f = hero_on_floor(h);        if (h->floor && !f) {            h->floor->busy = 0;            h->floor = 0;        };            if (f) {            if (!h->floor) {                h->bar->level = MAX(h->bar->level, f->level);                h->bar->score = MAX(h->bar->score, f->index);                bar_update(h->bar);                h->power += PHYS_LAND_POWER;            }            h->floor = f;            h->floor->busy = 1;            h->y = h->floor->y - 1;            h->vy = 0;        }    }}static voidhero_physics(hero_t *h, Uint32 dt){    float air_acc, gnd_acc, grv_acc;    float air_res, gnd_res;    float cur_acc, cur_res;    air_acc = PHYS_AIR_ACCEL * dt;    gnd_acc = PHYS_GND_ACCEL * dt;    grv_acc = PHYS_GRV_ACCEL * dt;    air_res = PHYS_AIR_RESISTANCE * dt;    gnd_res = PHYS_GND_RESISTANCE * dt;    if (h->floor) {        h->vy = 0;        cur_acc = gnd_acc;        cur_res = gnd_res;    } else {        h->vy += grv_acc;        cur_acc = air_acc;        cur_res = air_res;    }    if (h->power > dt) {        h->power-=dt;    }    /* if requested to run */    if (h->left_req) {        h->vx -= cur_acc;    }    if (h->right_req) {        h->vx += cur_acc;    }    /* if not requested to run, add a friction */    if (h->vx < 0 && !h->left_req) {        h->vx += cur_res;        if (h->vx > 0) {            h->vx = 0;        }    }    if (h->vx > 0 && !h->right_req) {        h->vx -= cur_res;        if (h->vx < 0) {            h->vx = 0;        }    }    /* handle jump request */    if (h->jump_req && h->floor) {        h->vy = 0            - PHYS_JUMP_BASE            - fabs(h->vx) * PHYS_JUMP_SPEED_COEFF            - h->power * PHYS_JUMP_POWER_COEFF;    }}hero_t *hero_new(game_t *g, map_t *m, bar_t *b){    hero_t *h;        h = xmalloc(sizeof(hero_t));        h->game = g;    h->map = m;    h->bar = b;    h->alive = 1;    h->vx = 0;    h->vy = 0;    h->left_req = 0;    h->right_req = 0;    h->jump_req = 0;    h->floor = m->floor_head;    h->floor->busy = 1;    h->power = 0;    h->y = h->floor->y - 1;    h->x = m->x0 + m->w / 2;    h->glyphs[0][0] = surface_load("hero_stand_l0.png", 1);    h->glyphs[0][1] = surface_load("hero_stand_l1.png", 1);    h->glyphs[0][2] = surface_load("hero_run_l0.png", 1);    h->glyphs[0][3] = surface_load("hero_run_l1.png", 1);    h->glyphs[0][4] = surface_load("hero_run_l2.png", 1);    h->glyphs[0][5] = surface_load("hero_run_l3.png", 1);    h->glyphs[0][6] = surface_load("hero_run_l4.png", 1);    h->glyphs[0][7] = surface_load("hero_run_l5.png", 1);    h->glyphs[0][8] = surface_load("hero_rise_l0.png", 1);    h->glyphs[0][9] = surface_load("hero_fall_l0.png", 1);    h->glyphs[1][0] = surface_load("hero_stand_r0.png", 1);    h->glyphs[1][1] = surface_load("hero_stand_r1.png", 1);    h->glyphs[1][2] = surface_load("hero_run_r0.png", 1);    h->glyphs[1][3] = surface_load("hero_run_r1.png", 1);    h->glyphs[1][4] = surface_load("hero_run_r2.png", 1);    h->glyphs[1][5] = surface_load("hero_run_r3.png", 1);    h->glyphs[1][6] = surface_load("hero_run_r4.png", 1);    h->glyphs[1][7] = surface_load("hero_run_r5.png", 1);    h->glyphs[1][8] = surface_load("hero_rise_r0.png", 1);    h->glyphs[1][9] = surface_load("hero_fall_r0.png", 1);    h->glyph = h->glyphs[1][0];    debug("hero initialized");    return h;}voidhero_free(hero_t *h){    Uint8 i;    for (i = 0; i < 10; i++) {        SDL_FreeSurface(h->glyphs[0][i]);        SDL_FreeSurface(h->glyphs[1][i]);    }    if (h->floor) {        h->floor->busy = 0;    }    free(h);    debug("hero freed");    return;}voidhero_draw(hero_t *h, SDL_Surface *s){    surface_blit(h->x, h->y - h->glyph->clip_rect.h, h->glyph, s);}static voidhero_move(hero_t *h, Uint32 dt){    static double ddx = 0;    static double ddy = 0;    Sint16 dx, dy;        ddx += h->vx * dt;    ddy += h->vy * dt;    dx = ceil(ddx); ddx-=dx;    dy = ceil(ddy); ddy-=dy;    if (dy <= 0) {        h->x += dx;        h->y += dy;    } else {        double x_step = dx / dy;        double save_vx = h->vx;        while (dy > 0) {            h->y++;            dy--;            h->x += x_step;            dx -= x_step;            hero_fix(h, dt);            if (h->game->state == GAME_OVER)                return;            if (save_vx != h->vx)                x_step = -x_step;            if (h->vy == 0)                dy = 0;        }        h->x += dx;    }    hero_fix(h, dt);}voidhero_tick(hero_t *h, Uint32 dt){    hero_physics(h, dt);    hero_move(h, dt);    hero_anim(h, dt);}/* --- file: bar.c ---------------------------------------------------------- */#include "jumpjump.h"static SDL_Surface *bar_render_text(bar_t *b, const char *x){    static SDL_Color c = {255, 255, 255};    SDL_Surface *r;    if (!(r = TTF_RenderText_Blended(b->font, x, c)))        fatal("couldn't render text: %s", x);    return r;}bar_t *bar_new(game_t *g, Sint16 x0, Uint16 w){    bar_t *b;    b = xmalloc(sizeof(bar_t));    b->font = font_load("font.ttf", 30);    b->x0 = x0;    b->x1 = x0 + w - 1;;    b->level_x = b->x1 - 10;    b->score_x = b->x0 + 10;    b->score_surface = bar_render_text(b, "dummy");    b->level_surface = bar_render_text(b, "dummy");    b->score = 0;    b->level = 0;    bar_update(b);        debug("bar initialized");    return b;}voidbar_update(bar_t *b){    char buf[32];    snprintf(buf, 32, "score: %d", b->score);    SDL_FreeSurface(b->score_surface);    b->score_surface = bar_render_text(b, buf);    snprintf(buf, 32, "level: %d", b->level);    SDL_FreeSurface(b->level_surface);    b->level_surface = bar_render_text(b, buf);    b->level_x = b->x0 + b->level_surface->w + 50;}voidbar_free(bar_t *b){    TTF_CloseFont(b->font);    SDL_FreeSurface(b->score_surface);    SDL_FreeSurface(b->level_surface);    free(b);    debug("bar freed");}voidbar_draw(bar_t *b, SDL_Surface *s){    surface_blit(b->score_x, 5, b->score_surface, s);    surface_blit(b->level_x, 5, b->level_surface, s);}/* --- file: game.c --------------------------------------------------------- */typedef struct {    Uint16 screen_width;    Uint16 screen_height;    Uint16 map_x0;    Uint16 map_y0;    SDLKey key_left;    SDLKey key_right;    SDLKey key_jump;} gameinfo_t;static gameinfo_t gameinfo[2] = {    {MAP_WIDTH,     MAP_HEIGHT, 0,         0, SDLK_LEFT, SDLK_RIGHT, SDLK_SPACE},    {MAP_WIDTH * 2, MAP_HEIGHT, MAP_WIDTH, 0, SDLK_a,    SDLK_d,     SDLK_s}};static void game_handle_events(game_t *g);static voidgame_handle_events(game_t *g){    SDL_Event event;    Uint8 *keys;    Uint8 i;    while (SDL_PollEvent(&event)) {        if (event.type == SDL_QUIT)             g->state = GAME_QUIT;    }    keys = SDL_GetKeyState(NULL);    if (keys[SDLK_F9])        g->map[0]->floor_cheat = 1;    if (keys[SDLK_ESCAPE])        g->state = GAME_OVER;    for (i = 0; i < g->nplayers; i++) {        g->hero[i]->left_req = keys[gameinfo[i].key_left];        g->hero[i]->right_req = keys[gameinfo[i].key_right];        g->hero[i]->jump_req = keys[gameinfo[i].key_jump];    }}game_t *game_new(screen_t *s, Uint8 nplayers){    game_t *g;    Uint8 i;    g = xmalloc(sizeof(game_t));    g->screen = s;    g->state = GAME_READY;    g->nplayers = nplayers;    screen_resize(s, gameinfo[nplayers-1].screen_width,                     gameinfo[nplayers-1].screen_height);    g->map = xmalloc(sizeof(map_t *) * nplayers);    g->hero = xmalloc(sizeof(hero_t *) * nplayers);    g->bar = xmalloc(sizeof(bar_t *) * nplayers);    for (i = 0; i < nplayers; i++) {        g->map[i] = map_new(g, gameinfo[i].map_x0,            gameinfo[i].map_y0, MAP_WIDTH, MAP_HEIGHT);        g->bar[i] = bar_new(g, g->map[i]->x0, g->map[i]->w);        g->hero[i] = hero_new(g, g->map[i], g->bar[i]);    }    /* draw everything to temporary surface first to blend it */    SDL_Surface *tmp = surface_new(g->screen->surface->w,                                   g->screen->surface->h);    for (i = 0; i < nplayers; i++) {        map_draw(g->map[i], tmp);        hero_draw(g->hero[i], tmp);        bar_draw(g->bar[i], tmp);    }    surface_blend_2(tmp, s->surface);    SDL_FreeSurface(tmp);    SDL_Flip(s->surface);    debug("game initialized");    return g;}voidgame_free(game_t *g){    Sint8 i;    for (i = g->nplayers - 1; i >= 0; i--) {        bar_free(g->bar[i]);        hero_free(g->hero[i]);        map_free(g->map[i]);    }    free(g);    debug("game freed");}voidgame_loop(game_t *g){    Uint32 dt, t;    Uint8 i, dead_heroes;    g->state = GAME_PLAY;    t = SDL_GetTicks();    while (g->state == GAME_PLAY) {        dt = SDL_GetTicks() - t;        game_handle_events(g);        dead_heroes = 0;        for (i = 0; i < g->nplayers; i++) {            if (!g->hero[i]->alive) {                dead_heroes++;                 continue;            }            map_tick(g->map[i], dt);            hero_tick(g->hero[i], dt);        }        if (dead_heroes == g->nplayers) {            g->state = GAME_OVER;        }        for (i = 0; i < g->nplayers; i++) {            map_draw(g->map[i], g->screen->surface);            hero_draw(g->hero[i], g->screen->surface);            bar_draw(g->bar[i], g->screen->surface);        }        for (i = 0; i < g->nplayers; i++) {            SDL_UpdateRect(g->screen->surface, g->map[i]->x0,                    g->map[i]->y0, g->map[i]->w, g->map[i]->h);        }        t += dt;    }    if (g->state == GAME_OVER) {        message_t *msg = message_new(g->screen->surface, "Game Over");        message_draw(msg);        delay(2000);        message_free(msg);    }}